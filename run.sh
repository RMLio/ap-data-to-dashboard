#!/usr/bin/env bash
# Usage: find out by running:
#   ./run.sh -h

# Exit on error, undefined variable, or error in pipeline
set -euo pipefail
# Unmatched globs expand to nothing
shopt -s nullglob  

# Constants
in_dir="in"
out_dir="out"
template_schema_json="$in_dir/template.schema.json"
queries_dir="$out_dir/queries"
queries_combined_file="$queries_dir/generated-queries.rq"
queries_split_dir="$queries_dir/generated-queries"
rdf_dir="$out_dir/serve-me"
miravi_main_dir="subprojects/miravi-a-linked-data-viewer/main"
miravi_initial_config_dir="miravi-initial-config"

# Default argument values
dataUrl="http://localhost:5500/"
delimiter="|"
buildMiravi=true

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -u)
      dataUrl="$2"
      shift 2
      ;;
    -d)
      delimiter="$2"
      shift 2
      ;;
    -n|--noMiraviBuild)
      buildMiravi=false
      shift
      ;;
    -h|--help)
      echo "Usage: $0 -u <dataUrl> -d <delimiter> [-n | --noMiraviBuild]"
      echo "  <dataUrl>:     default='http://localhost:5500/'"
      echo "  <delimiter>:   default='|'"
      echo "  noMiraviBuild: do not build Miravi and delete previous build"
      exit 1
      ;;
    -*)
      echo "Unknown option: $1"
      exit 1
      ;;
    *)
      echo "Unexpected argument: $1"
      exit 1
      ;;
  esac
done

rm -rf $out_dir

noInputFiles=false
inputs=("$in_dir"/*.xlsx)
if [ ${#inputs[@]} -eq 0 ]; then
  echo "❌ No input files found."
  noInputFiles=true
fi

noSchemaFile=false
schema=("$in_dir"/*.json)
if [ ${#inputs[@]} -eq 0 ]; then
  echo "❌ No schema file found."
  noSchemaFile=true
fi

if [[ "$noInputFiles" == false && "$noSchemaFile" == false ]]; then
  for input in "$in_dir"/*.xlsx; do
    base=$(basename "$input")
    echo "Processing file: $base"
    fileName="${base%.xlsx}"        # removes extension → file.xlsx → file

    echo "ℹ️  Processing file: $input"
    node ./src/dataxlsx-to-datajson.js -i $input -o $out_dir -d $delimiter

    echo "ℹ️  Generating file: $out_dir/$fileName.mapping.yml"
    node ./src/schema-to-yarrrml.js -i "$template_schema_json" -o "$out_dir/$fileName.mapping.yml" -s "$out_dir/$fileName.json"

    echo "ℹ️  Generating file: $out_dir/$fileName.mapping.rml.ttl"
    npx @rmlio/yarrrml-parser -i "$out_dir/$fileName.mapping.yml" -o "$out_dir/$fileName.mapping.rml.ttl" -p

    # temporary solution because base is not generated by YARRRML Parser, and default base in RMLMapper doesn't end with /
    echo '@base <http://example.com/> .' | cat - "$out_dir/$fileName.mapping.rml.ttl" > "temp" && mv "temp" "$out_dir/$fileName.mapping.rml.ttl"

    echo "ℹ️  Generating file: $rdf_dir/$fileName.ttl"
    mkdir -p $rdf_dir
    java -jar ./rmlmapper-7.3.3-r374-all.jar -m $out_dir/$fileName.mapping.rml.ttl -o $rdf_dir/$fileName.ttl -s turtle
  done

  # Use the first input file to generate the combined and split queries, temporary solution until I have a separate schema file
  first_file=$(ls "$out_dir"/*.json | head -n 1)
  echo "ℹ️  Generating combined queries file $queries_combined_file and split queries in $queries_split_dir"
  node ./src/schema-to-sparql.js -i "$template_schema_json" -o "$queries_combined_file" -s "$queries_split_dir"
else
  echo "ℹ️  Generating (empty) file $rdf_dir/empty.ttl."
  mkdir -p $rdf_dir
  echo "" > $rdf_dir/empty.ttl
  echo "ℹ️  Generating (empty) combined queries file $queries_combined_file and (no) split queries in $queries_split_dir"
  mkdir -p "$queries_dir"
  echo "" > "$queries_combined_file"
  mkdir -p "$queries_split_dir"
fi

echo "ℹ️  Preparing Miravi configuration in $miravi_main_dir"
node ./src/prepare-miravi-config.js -i "$miravi_initial_config_dir" -s "$queries_split_dir" -o "$miravi_main_dir" -u "$dataUrl" -d "$rdf_dir"

if [[ "$buildMiravi" == true ]]; then
  echo "ℹ️  Building Miravi in $miravi_main_dir into $miravi_main_dir/dist; see $miravi_main_dir/build.log for details..."
  (cd $miravi_main_dir && npm run build > build.log 2>&1)
else
  echo "ℹ️  Skipping Miravi build; deleting previous Miravi build..."
  rm -rf $miravi_main_dir/dist
fi